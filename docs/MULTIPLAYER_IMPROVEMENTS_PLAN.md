# План улучшения мультиплеера Protocol TX

## ✅ РЕАЛИЗОВАНО (12.01.2026)

### Все критические улучшения завершены:

1. ✅ **Client-Side Prediction** - реализовано предсказание движения локального игрока
2. ✅ **Server Reconciliation** - исправление расхождений между клиентом и сервером
3. ✅ **Real Ping Measurement** - точное измерение RTT и jitter через ping/pong
4. ✅ **Binary Serialization** - бинарная сериализация с квантизацией (MessagePack-like)
5. ✅ **Improved Delta Compression** - оптимизированная дельта-компрессия
6. ✅ **Adaptive Update Rate** - динамическая частота обновлений на основе расстояния
7. ✅ **Cubic Interpolation** - плавное движение через Hermite сплайны
8. ✅ **Dead Reckoning** - экстраполяция движения при потере пакетов
9. ✅ **Jitter Buffer** - сглаживание вариаций задержки
10. ✅ **Spatial Partitioning** - Spatial Hash Grid для оптимизации трафика
11. ✅ **Optimized Batch Updates** - группировка сообщений с лимитами размера
12. ✅ **Rate Limiting** - защита от спама сообщениями

### Файлы реализации:
- `src/server/spatialHash.ts` - Spatial Hash Grid
- `src/server/gameServer.ts` - интеграция всех оптимизаций
- `src/client/multiplayer.ts` - prediction, reconciliation, jitter buffer
- `src/client/networkPlayerTank.ts` - cubic interpolation, dead reckoning
- `src/shared/protocol.ts` - бинарная сериализация

---

## Текущее состояние

### Что уже есть ✅

- WebSocket сервер с авторитетной логикой (60 Hz tick rate)
- ✅ Client-Side Prediction с Server Reconciliation
- ✅ Cubic интерполяция с Dead Reckoning
- ✅ Бинарная сериализация с квантизацией
- ✅ Дельта-компрессия с приоритизацией по расстоянию
- ✅ Spatial Partitioning (Spatial Hash Grid)
- ✅ Optimized Batch Updates
- ✅ Real ping measurement (RTT + Jitter)
- ✅ Адаптивная интерполяция на основе ping
- ✅ Rate limiting для защиты сервера
- Синхронизация выстрелов и снарядов
- Поддержка различных игровых режимов (FFA, TDM, Co-op, Battle Royale, CTF)

### Решённые проблемы ✅

1. ~~**Нет client-side prediction**~~ - ✅ РЕАЛИЗОВАНО
2. ~~**Нет server reconciliation**~~ - ✅ РЕАЛИЗОВАНО
3. ~~**JSON сериализация**~~ - ✅ БИНАРНАЯ СЕРИАЛИЗАЦИЯ
4. ~~**Хардкод ping**~~ - ✅ REAL PING MEASUREMENT
5. ~~**Базовая интерполяция**~~ - ✅ CUBIC INTERPOLATION + DEAD RECKONING
6. ~~**Дельта-компрессия простая**~~ - ✅ УЛУЧШЕННАЯ С КВАНТИЗАЦИЕЙ
7. ~~**Нет адаптивной оптимизации**~~ - ✅ ADAPTIVE UPDATE RATE + SPATIAL PARTITIONING
8. **Античит базовый** - можно улучшить для защиты от более продвинутых читов

---

## Фаза 1: Критичные улучшения (Client-Side Prediction & Reconciliation)

### 1.1 Реализация Client-Side Prediction

**Цель**: Мгновенный отклик на ввод игрока без ожидания серверного подтверждения.

**Файлы для изменения**:
- `src/client/multiplayer.ts` - добавить систему предсказания
- `src/client/tankController.ts` - интегрировать предсказание в физику
- `src/shared/types.ts` - добавить sequence numbers

**Технические детали**:

1. **Структура данных для предсказания**:
```typescript
interface PredictedState {
    sequence: number;
    timestamp: number;
    position: Vector3;
    rotation: number;
    turretRotation: number;
    input: PlayerInput;
}

interface ClientPredictionState {
    predictedStates: Map<number, PredictedState>; // sequence -> state
    confirmedSequence: number; // Последний подтвержденный сервером sequence
    lastServerState: PlayerData | null;
}
```

2. **Алгоритм**:
   - Клиент генерирует sequence number для каждого input (инкремент)
   - При вводе игрока: сразу применяется локально и сохраняется в predictedStates
   - Локальный танк движется с применением всех неподтвержденных inputs
   - При получении серверного состояния: находим confirmedSequence и откатываем все состояния после него

3. **Интеграция с TankController**:
   - Разделить физику на две фазы: prediction (локальная) и reconciliation (серверная коррекция)
   - Prediction работает на каждом кадре с локальными inputs
   - Reconciliation применяется при получении серверных обновлений

**Ожидаемый результат**: Уменьшение воспринимаемой задержки с ~100ms до ~0ms для локального игрока.

### 1.2 Server Reconciliation

**Цель**: Синхронизация клиентского предсказания с серверным состоянием.

**Файлы для изменения**:
- `src/client/multiplayer.ts` - добавить логику reconciliation
- `src/server/gameServer.ts` - добавить sequence numbers в ответы сервера
- `src/shared/messages.ts` - добавить sequence в PlayerStates сообщение

**Технические детали**:

1. **Сервер отправляет sequence**:
```typescript
interface ServerPlayerStates {
    players: PlayerData[];
    gameTime: number;
    serverSequence: number; // Sequence последнего обработанного input
}
```

2. **Клиент reconciliation**:
   - При получении серверного состояния находим confirmedSequence
   - Откатываем локальное состояние к confirmedSequence
   - Применяем серверное состояние как "правду"
   - Re-apply все predicted inputs после confirmedSequence с нуля

3. **Оптимизация**:
   - Ограничить размер истории (последние 60 состояний = 1 секунда при 60Hz)
   - Использовать бинарный поиск для поиска confirmedSequence
   - Batch reconciliation для множественных обновлений

**Ожидаемый результат**: Плавная коррекция при рассинхронизации без видимых "телепортаций".

### 1.3 Измерение реального ping

**Цель**: Точное измерение RTT для адаптивной компенсации задержки.

**Файлы для изменения**:
- `src/client/multiplayer.ts` - добавить ping/pong
- `src/server/gameServer.ts` - обработать ping/pong
- `src/shared/messages.ts` - добавить PING/PONG типы

**Технические детали**:

1. **Ping/Pong механизм**:
```typescript
// Клиент отправляет каждые 1000ms
{
    type: "ping",
    data: { timestamp: number, sequence: number }
}

// Сервер отвечает сразу
{
    type: "pong",
    data: { timestamp: number, sequence: number }
}
```

2. **Расчет RTT**:
   - RTT = currentTime - pingTimestamp
   - Хранить историю последних 10 RTT измерений
   - Использовать экспоненциально взвешенное среднее (EWMA): `rtt = 0.875 * oldRtt + 0.125 * newRtt`
   - Также рассчитывать jitter: вариация RTT

3. **Использование RTT**:
   - Заменить хардкод 100ms в lag compensation на реальный RTT
   - Адаптивная задержка интерполяции на основе RTT
   - Динамическая настройка буферов на основе jitter

**Ожидаемый результат**: Точная компенсация задержки для всех игроков независимо от их ping.

---

## Фаза 2: Оптимизация протокола

### 2.1 Бинарная сериализация

**Цель**: Уменьшить размер сетевых сообщений на 40-60%.

**Файлы для изменения**:
- `src/shared/protocol.ts` - заменить JSON на бинарную сериализацию
- `package.json` - добавить зависимость (msgpack-lite или @msgpack/msgpack)

**Технические детали**:

1. **Выбор библиотеки**: `@msgpack/msgpack` (современная, TypeScript-friendly)

2. **Квантизация чисел**:
   - Позиции: float32 → int16 (точность 0.1 единиц, диапазон ±3276.7)
   - Повороты: float32 → int16 (точность 0.001 радиан, диапазон ±32.767)
   - Здоровье: float32 → uint8 (0-255, точность 0.392)

3. **Битовая упаковка флагов**:
   - isShooting, status, team → упаковывать в один байт

4. **Оптимизация структур**:
   - Удалить избыточные поля
   - Использовать схемы для разных типов сообщений

**Ожидаемый результат**: Размер PLAYER_STATES сообщения уменьшится с ~500 байт до ~200-300 байт.

### 2.2 Улучшенная дельта-компрессия

**Цель**: Отправлять только изменившиеся данные с максимальной эффективностью.

**Файлы для изменения**:
- `src/server/deltaCompression.ts` - улучшить алгоритм

**Технические детали**:

1. **Умная квантизация**:
   - Использовать пороги значимости изменений (dead zones)
   - Позиция: изменение < 0.05 единиц → не отправлять
   - Поворот: изменение < 0.01 радиан → не отправлять

2. **Приоритетная компрессия**:
   - Близкие игроки: высокая точность (int16)
   - Дальние игроки: низкая точность (int8) или пропуск обновлений

3. **Битовая упаковка дельт**:
   - Использовать битовые маски для указания измененных полей
   - Например: 1 байт = 8 флагов (position, rotation, turret, aim, health, status, kills, deaths)

**Ожидаемый результат**: Дополнительное снижение трафика на 30-40% при сохранении качества.

### 2.3 Адаптивная частота обновлений

**Цель**: Оптимизировать частоту обновлений на основе расстояния и нагрузки.

**Файлы для изменения**:
- `src/server/gameServer.ts` - добавить адаптивную логику
- `src/server/room.ts` - индивидуальная частота для каждого игрока

**Технические детали**:

1. **Частоты обновлений**:
   - Близкие игроки (< 50 единиц): 60 Hz
   - Средние (50-150 единиц): 30 Hz
   - Дальние (> 150 единиц): 15 Hz
   - Очень дальние (> 300 единиц): 10 Hz или только события

2. **Адаптация на основе нагрузки**:
   - Если tick time > 14ms: снизить частоту на 10%
   - Если tick time < 12ms: повысить частоту на 5%
   - Динамический баланс

3. **Приоритетные события**:
   - Выстрелы, попадания, смерти → всегда отправляются немедленно
   - Не зависят от адаптивной частоты

**Ожидаемый результат**: Снижение нагрузки на сервер на 30-50% при сохранении качества для ближних игроков.

---

## Фаза 3: Улучшенная компенсация задержки

### 3.1 Lag Compensation на сервере

**Цель**: Честная обработка попаданий с учетом сетевой задержки.

**Файлы для изменения**:
- `src/server/projectile.ts` - добавить lag compensation
- `src/server/player.ts` - хранить историю позиций
- `src/server/room.ts` - использовать историю при проверке попаданий

**Технические детали**:

1. **Хранение истории на сервере**:
```typescript
interface PositionSnapshot {
    position: Vector3;
    rotation: number;
    timestamp: number;
}

// В ServerPlayer
positionHistory: PositionSnapshot[]; // Последние 1 секунда (60 snapshots)
```

2. **Алгоритм lag compensation**:
   - При получении выстрела: используем RTT игрока
   - Rewind time: currentTime - (RTT / 2) // Half RTT для компенсации
   - Находим ближайший snapshot в истории
   - Проверяем попадание по исторической позиции

3. **Ограничения**:
   - Максимальный rewind: 300ms (защита от очень высокого ping)
   - Если rewind > 300ms: используем текущую позицию

**Ожидаемый результат**: Справедливая игра для всех игроков независимо от ping (до 300ms).

### 3.2 Улучшенная интерполяция

**Цель**: Плавное движение удаленных игроков даже при нестабильной сети.

**Файлы для изменения**:
- `src/client/networkPlayerTank.ts` - улучшить интерполяцию

**Технические детали**:

1. **Cubic interpolation вместо линейной**:
   - Использовать Hermite или Catmull-Rom сплайн
   - Более плавное движение при ускорениях/замедлениях

2. **Dead reckoning (экстраполяция)**:
   - При пропуске обновлений: предсказывать движение на основе последней скорости
   - Формула: `predictedPos = lastPos + velocity * deltaTime`
   - Ограничить максимальное время экстраполяции (500ms)

3. **Адаптивная скорость интерполяции**:
   - Низкий ping (< 50ms): быстрая интерполяция (α = 0.3)
   - Средний (50-150ms): нормальная (α = 0.2)
   - Высокий (> 150ms): медленная (α = 0.1) для сглаживания джиттера

**Ожидаемый результат**: Плавное движение удаленных игроков даже при нестабильной сети.

### 3.3 Jitter Buffer

**Цель**: Сглаживание вариаций задержки (jitter).

**Файлы для изменения**:
- `src/client/multiplayer.ts` - добавить jitter buffer

**Технические детали**:

1. **Буферизация обновлений**:
```typescript
interface BufferedUpdate {
    data: PlayerData[];
    timestamp: number;
    sequence: number;
}

class JitterBuffer {
    private buffer: BufferedUpdate[] = [];
    private targetDelay: number = 50; // Начальная задержка (ms)
    
    addUpdate(update: BufferedUpdate): void {
        // Добавляем в буфер с сортировкой по sequence
    }
    
    getNextUpdate(currentTime: number): PlayerData[] | null {
        // Возвращаем обновление, если прошло targetDelay времени
    }
}
```

2. **Адаптивная задержка**:
   - Рассчитывать jitter как стандартное отклонение RTT
   - targetDelay = baseDelay + (jitter * 2)
   - Динамически корректировать при изменении jitter

3. **Обработка пропусков**:
   - Если обновление опоздало > 200ms: пропускаем (устаревшее)
   - При большом количестве пропусков: увеличить targetDelay

**Ожидаемый результат**: Устранение рывков и скачков при нестабильной сети.

---

## Фаза 4: Расширенный античит

### 4.1 Улучшенная валидация

**Цель**: Защита от продвинутых читов (aimbot, speedhack, etc).

**Файлы для изменения**:
- `src/server/validation.ts` - расширить валидацию

**Технические детали**:

1. **Статистический анализ**:
   - Детекция aimbot: анализ паттернов прицеливания (слишком точное, мгновенное)
   - Проверка угловых скоростей поворота башни (невозможные значения)
   - Анализ точности попаданий (слишком высокая = подозрительно)

2. **Валидация последовательности действий**:
   - Невозможные комбинации (стрельба без перезарядки)
   - Слишком быстрые действия (реакция < 50ms подозрительна)
   - Проверка физической возможности (ускорение, изменение направления)

3. **Машинное обучение (опционально)**:
   - Сбор статистики поведения
   - Детекция аномалий через ML модели
   - Автоматическое обучение на новых паттернах

**Ожидаемый результат**: Снижение количества читов на 80%+.

### 4.2 Server-Side Hit Validation

**Цель**: Полная авторитетность сервера в вопросах попаданий.

**Файлы для изменения**:
- `src/server/projectile.ts` - серверная симуляция попаданий
- `src/client/tankController.ts` - убрать клиентские попадания

**Технические детали**:

1. **Серверная симуляция**:
   - Все попадания проверяются только на сервере
   - Клиент отправляет только выстрел, не результат попадания
   - Сервер симулирует траекторию снаряда и проверяет коллизии

2. **Удаление клиентских попаданий**:
   - Убрать локальную проверку попаданий по сетевым игрокам
   - Оставить только визуальные эффекты (после серверного подтверждения)

3. **Оптимизация**:
   - Пространственная индексация для быстрой проверки коллизий
   - Кэширование результатов проверок

**Ожидаемый результат**: Невозможность использовать читы для попаданий.

### 4.3 Rate Limiting и Throttling

**Цель**: Защита от спама и DDoS атак.

**Файлы для изменения**:
- `src/server/gameServer.ts` - улучшить rate limiting
- `src/server/player.ts` - добавить более строгие лимиты

**Технические детали**:

1. **Многоуровневый rate limiting**:
   - Per-connection: максимум 100 сообщений/сек
   - Per-message-type: максимум 60 inputs/сек, 10 выстрелов/сек
   - Adaptive: снижение лимитов при подозрительном поведении

2. **Автоматический бан**:
   - 3 нарушения за 60 секунд → временный бан (5 минут)
   - 10 нарушений за час → бан на час
   - Повторные нарушения → перманентный бан

3. **Мониторинг**:
   - Логирование всех нарушений
   - Статистика по игрокам
   - Автоматические алерты при массовых нарушениях

**Ожидаемый результат**: Защита от спама и злоупотреблений.

---

## Фаза 5: Оптимизация производительности

### 5.1 Spatial Partitioning

**Цель**: Отправлять обновления только видимым игрокам.

**Файлы для изменения**:
- `src/server/spatialHash.ts` (новый файл) - реализация spatial hash
- `src/server/room.ts` - интегрировать spatial partitioning

**Технические детали**:

1. **Spatial Hash Grid**:
   - Разделить мир на ячейки 100x100 единиц
   - Каждый игрок находится в одной или нескольких ячейках
   - При обновлении отправляем только игрокам в соседних ячейках

2. **Реализация**:
```typescript
class SpatialHashGrid {
    private cellSize: number = 100;
    private grid: Map<string, Set<string>>; // cellKey -> playerIds
    
    addPlayer(playerId: string, position: Vector3): void;
    getNearbyPlayers(playerId: string, position: Vector3): Set<string>;
    updatePlayer(playerId: string, oldPos: Vector3, newPos: Vector3): void;
}
```

3. **Оптимизация**:
   - Обновлять grid только при значительном перемещении (> 10 единиц)
   - Кэшировать результаты для статичных игроков

**Ожидаемый результат**: Снижение количества обновлений на 40-60% в больших матчах.

### 5.2 Batch Updates

**Цель**: Группировка обновлений для снижения overhead WebSocket.

**Файлы для изменения**:
- `src/server/gameServer.ts` - добавить batch систему

**Технические детали**:

1. **Группировка сообщений**:
   - Собирать все обновления за тик в один буфер
   - Отправлять одним сообщением вместо множественных

2. **Структура batch сообщения**:
```typescript
interface BatchMessage {
    type: "batch";
    data: {
        updates: Array<{
            type: ServerMessageType;
            data: any;
        }>;
    };
}
```

3. **Оптимизация**:
   - Максимальный размер batch: 16KB (размер WebSocket frame)
   - Если превышает: отправлять несколько batches

**Ожидаемый результат**: Снижение overhead на 20-30%.

### 5.3 Приоритизация обновлений

**Цель**: Максимизировать использование PrioritizedBroadcaster.

**Файлы для изменения**:
- `src/server/deltaCompression.ts` - полностью использовать PrioritizedBroadcaster
- `src/server/gameServer.ts` - применять приоритизацию

**Технические детали**:

1. **Улучшенная приоритизация**:
   - Расстояние (основной фактор)
   - Состояние игрока (живой важнее мертвого)
   - Активность (стреляющий важнее пассивного)
   - Важность события (выстрел критичен)

2. **Адаптивное количество**:
   - Низкая нагрузка: отправлять всех игроков
   - Средняя: топ-20
   - Высокая: топ-10

**Ожидаемый результат**: Лучшее качество для важных игроков при снижении нагрузки.

---

## Метрики успеха

### Ключевые показатели (KPI)

1. **Воспринимаемая задержка**: ↓ 50-70% (с ~100ms до ~30ms)
2. **Размер сетевых сообщений**: ↓ 40-60% (с ~500 байт до ~200-300 байт)
3. **Нагрузка на сервер**: ↓ 30-50% (больше игроков на сервер)
4. **Стабильность при высоком ping**: Работает стабильно до 300ms
5. **Количество читов**: ↓ 80%+ (за счет серверной валидации)
6. **Качество интерполяции**: Плавное движение даже при нестабильной сети

### Метрики для мониторинга

- Средний RTT по игрокам
- Jitter (вариация RTT)
- Размер исходящих сообщений
- Частота обновлений (фактическая)
- Количество reconciliation rollbacks
- Количество античит нарушений

---

## План реализации

### Неделя 1-2: Фаза 1 (Критичные улучшения)
- День 1-3: Client-side prediction
- День 4-6: Server reconciliation
- День 7-9: Ping measurement
- День 10-14: Тестирование и отладка

### Неделя 3-4: Фаза 2 (Оптимизация протокола)
- День 1-5: Бинарная сериализация
- День 6-9: Улучшенная дельта-компрессия
- День 10-12: Адаптивная частота обновлений
- День 13-14: Тестирование

### Неделя 5-6: Фаза 3 (Компенсация задержки)
- День 1-4: Lag compensation на сервере
- День 5-8: Улучшенная интерполяция
- День 9-11: Jitter buffer
- День 12-14: Тестирование

### Неделя 7-8: Фаза 4 (Античит)
- День 1-5: Улучшенная валидация
- День 6-8: Server-side hit validation
- День 9-11: Rate limiting
- День 12-14: Тестирование

### Неделя 9-10: Фаза 5 (Оптимизация)
- День 1-5: Spatial partitioning
- День 6-8: Batch updates
- День 9-11: Приоритизация
- День 12-14: Финальное тестирование и оптимизация

---

## Риски и митигация

### Технические риски

1. **Сложность client-side prediction**
   - Риск: Баги при reconciliation могут вызвать визуальные артефакты
   - Митигация: Тщательное тестирование, постепенное внедрение, возможность отключения

2. **Производительность бинарной сериализации**
   - Риск: Может быть медленнее JSON на малых данных
   - Митигация: Бенчмарки, fallback на JSON если медленнее

3. **Совместимость версий**
   - Риск: Старые клиенты не совместимы с новым протоколом
   - Митигация: Версионирование протокола, поддержка обеих версий временно

### Риски производительности

1. **Память для истории состояний**
   - Риск: Большое потребление памяти при хранении истории
   - Митигация: Ограничение размера истории, периодическая очистка

2. **CPU нагрузка от reconciliation**
   - Риск: Re-simulation может быть тяжелой
   - Митигация: Оптимизация алгоритма, ограничение глубины истории

---

## Тестирование

### Unit тесты
- Тестирование всех новых алгоритмов (compression, interpolation, validation)
- Проверка корректности reconciliation

### Integration тесты
- Тестирование полного цикла клиент-сервер
- Проверка совместимости версий

### Load тесты
- Тестирование с 32+ игроками
- Тестирование при высоком ping (150-300ms)
- Тестирование при нестабильной сети (jitter)

### User acceptance тестирование
- Тестирование с реальными игроками
- Сбор feedback по ощущениям от gameplay

---

## Заключение

Этот план обеспечивает комплексное улучшение мультиплеера Protocol TX, начиная с критичных улучшений отзывчивости (client-side prediction) и заканчивая оптимизацией производительности. Реализация должна происходить поэтапно с тщательным тестированием на каждом этапе.

