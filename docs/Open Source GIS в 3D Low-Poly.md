# **Архитектурный анализ и техническая стратегия реализации конвейера преобразования GIS-данных в 3D Low-Poly/Voxel для проекта Protocol TX**

## **Техническое резюме**

Настоящий отчет представляет собой исчерпывающий анализ технологического стека и алгоритмической базы, необходимой для реализации проекта Protocol TX. Задача преобразования разнородных данных геоинформационных систем (GIS) в стилизованную трехмерную среду (Low-Poly или Voxel) требует не просто рендеринга, а глубокой процедурной реконструкции исходных данных. В отличие от стандартных методов визуализации, которые стремятся к фотореализму, требуемая эстетика диктует необходимость алгоритмического упрощения, дискретизации и топологической оптимизации.  
Проведенный анализ открытых исходных кодов и научной литературы выявил, что, хотя единого коробочного решения для мгновенной конвертации «LAS в Voxel» не существует, экосистема JavaScript и WebGL/WebGPU располагает мощным набором модульных библиотек. Эти компоненты, будучи интегрированными в единый конвейер, способны решить поставленную задачу с высокой производительностью.  
Ключевыми архитектурными столпами предлагаемого решения являются:

1. **Асинхронная загрузка и парсинг:** Использование loaders.gl для потоковой обработки массивных облаков точек LIDAR.  
2. **Воксельная оптимизация:** Применение алгоритмов «Жадного построения сетки» (Greedy Meshing) для минимизации количества полигонов в воксельных структурах.  
3. **Адаптивный ландшафт:** Использование алгоритма CDLOD (Continuous Distance-Dependent Level of Detail) для рендеринга масштабных территорий без визуальных артефактов.  
4. **Процедурная генерация зданий:** Применение алгоритма «Прямого скелета» (Straight Skeleton) для создания геометрически корректных крыш на основе векторных данных OpenStreetMap (OSM).  
5. **Вычисления на GPU:** Перенос тяжелых вычислений (генерация карт высот, отсечение невидимых граней) на сторону видеокарты с помощью WebGPU Compute Shaders.

Далее представлен детальный разбор каждого этапа конвейера с ссылками на конкретные open-source реализации и анализом их применимости.

## ---

**1\. Стратегия приема и нормализации данных (Data Ingestion)**

Фундаментом любого GIS-проекта является эффективная работа с исходными данными. Для Protocol TX критически важно уметь обрабатывать два основных типа данных: облака точек (LIDAR) и векторные контуры (OSM). Основная сложность заключается в объемах данных и их бинарной природе.

### **1.1. Обработка облаков точек (LAS/LAZ)**

Форматы LAS и его сжатая версия LAZ являются индустриальным стандартом для хранения данных лазерного сканирования. Однако их структура, оптимизированная для хранения, крайне неудобна для прямого рендеринга в браузере.

#### **1.1.1. Экосистема loaders.gl**

Наиболее зрелым и архитектурно правильным решением для Node.js и браузерных сред является библиотека loaders.gl, разрабатываемая в рамках фонда vis.gl. Модуль @loaders.gl/las предоставляет стандартизированный интерфейс для чтения этих форматов.1  
**Архитектурные преимущества:**

* **Работа в воркерах:** Библиотека изначально спроектирована для работы в Web Workers. Это критически важно для Protocol TX, так как декомпрессия LAZ и парсинг миллионов точек в основном потоке приведет к полной заморозке интерфейса приложения.  
* **Типизация данных:** Загрузчик возвращает данные в формате, готовом для передачи в GPU (типизированные массивы Float32Array и Uint8Array). Это исключает накладные расходы на переформатирование данных перед рендерингом.2  
* **Доступ к классификации:** LIDAR-данные содержат байт классификации (ASPERS standard), который определяет, является ли точка землей, растительностью или зданием. loaders.gl предоставляет прямой доступ к атрибуту classification, что позволяет фильтровать данные *до* этапа генерации геометрии.4

Технические ограничения:  
Важно отметить, что текущая реализация @loaders.gl/las имеет ограниченную поддержку формата LAS 1.4, особенно в части расширенных определений волновых форм и 64-битных атрибутов. Если исходные данные проекта Protocol TX поступают в новейшем формате, может потребоваться этап препроцессинга (например, конвертация в LAS 1.2 с помощью утилиты PDAL) перед загрузкой в браузер.1

#### **1.1.2. Альтернативные подходы и легаси-решения**

В ходе исследования были рассмотрены и другие библиотеки, такие как node-las и нативные парсеры из Potree.

* **node-las:** Данный проект, ставивший целью портирование libLAS на Node.js, фактически заброшен и не рекомендуется к использованию в продакшн-среде из\-за проблем с производительностью при обработке 64-битных чисел в JavaScript.5  
* **Потоковое чтение:** Библиотека las-reader реализует интерфейс ReadableStream, что делает её полезной для серверной части Protocol TX, если потребуется обрабатывать файлы, превышающие объем оперативной памяти сервера (например, конвертация на лету).6

### **1.2. Проблема точности координат и плавающего начала**

GIS-данные обычно привязаны к глобальным координатам (например, UTM), значения которых могут достигать миллионов метров. При загрузке в 3D-движок (Babylon.js или Three.js) использование таких больших чисел приводит к "дрожанию" геометрии (floating point jitter) из\-за потери точности типа float32.  
**Решение:** Необходимо внедрение системы «Плавающего начала координат» (Floating Origin). При загрузке данных первый загруженный чанк становится центром локальной системы координат (0,0,0), а все последующие данные смещаются относительно него. Библиотеки типа loaders.gl поддерживают опцию fp64: true для хранения исходных данных в двойной точности, но для рендеринга всё равно требуется вычитание оффсета.1

## ---

**2\. Алгоритмы вокселизации и оптимизации (The Voxel Pipeline)**

Преобразование непрерывных данных в дискретные воксели — ключевая эстетическая задача Protocol TX. Наивный подход (рендеринг куба для каждой точки) технически несостоятелен при масштабах GIS.

### **2.1. Алгоритмическая база: Greedy Meshing (Жадное построение сетки)**

Этот алгоритм является «золотым стандартом» в разработке воксельных миров. Его суть заключается в объединении смежных вокселей одинакового типа в единый прямоугольник (квад), что сокращает количество треугольников на порядки.  
**Механика алгоритма:**

1. **Отсечение невидимых граней (Culling):** Если два вокселя соприкасаются, грань между ними не рисуется. Это первый этап оптимизации, реализованный в библиотеке voxel-to-mesh.7  
2. **Слияние (Merging):** Алгоритм проходит по каждому срезу воксельного объема (например, по оси Z).  
   * Он находит первый активный воксель.  
   * Пытается расширить выделение вправо (по X), пока воксели совпадают.  
   * Затем пытается расширить полученную полосу вниз (по Y).  
   * Генерирует один прямоугольник вместо сотен отдельных квадратов.8

Пример эффективности:  
Для чанка размером 32x32x32, полностью заполненного землей:

* *Наивный метод:* \~32,000 кубов \* 12 треугольников \= **393,216 треугольников**.  
* *Greedy Meshing:* 6 граней чанка \* 2 треугольника \= **12 треугольников**.

### **2.2. Open Source Реализации**

Для Protocol TX рекомендуется использовать готовые реализации, адаптированные под современные стандарты ES6+:

* **voxel-to-mesh:** Лаконичная библиотека, принимающая массив координат и возвращающая оптимизированную геометрию (вершины и индексы). Она автоматически удаляет внутренние грани и T-образные стыки, что критически важно для корректного освещения и затенения.7  
* **greedy-mesher (Mikola Lysenko):** Классическая реализация, работающая с n-мерными массивами (ndarray). Она требует более глубокой настройки, но предоставляет максимальную гибкость в определении правил слияния вокселей (например, можно запретить слияние вокселей с разной освещенностью).11

### **2.3. Работа с текстурами и материалами**

При объединении вокселей возникает проблема текстурирования: растягивать одну текстуру на большой квад или тайлить (повторять) её?  
Для Low-Poly стиля часто используются Текстурные Атласы (Texture Atlases).

* **maxrects-packer:** Библиотека для упаковки множества мелких текстур в одну большую. Это позволяет рендерить весь воксельный мир за один вызов отрисовки (Draw Call), так как не требуется переключение текстур.13  
* **Интеграция:** При генерации меша алгоритм Greedy Meshing должен рассчитывать UV-координаты так, чтобы они указывали на нужный регион атласа. Если воксели имеют разные цвета (Vertex Colors), алгоритм слияния должен учитывать цвет как критерий остановки: красный воксель не может быть объединен с синим.14

## ---

**3\. Реконструкция ландшафта: CDLOD и Интерполяция**

Если воксели идеальны для объектов и структур, то для базового рельефа местности (особенно на больших дистанциях) более эффективным является метод карт высот (Heightmaps).

### **3.1. Генерация карт высот из облака точек**

LIDAR предоставляет набор разрозненных точек, а не сплошную поверхность. Для создания карты высот (регулярной сетки) необходимо использовать алгоритмы пространственной интерполяции.

#### **3.1.1. Обратно взвешенное расстояние (IDW)**

Метод IDW (Inverse Distance Weighting) определяет высоту пикселя карты как средневзвешенное значение высот ближайших точек LIDAR, где вес обратно пропорционален расстоянию.16

$$Z \= \\frac{\\sum (z\_i / d\_i^p)}{\\sum (1 / d\_i^p)}$$

Где $p$ — параметр степени (обычно 2).

#### **3.1.2. Пространственная индексация (kdbush)**

Наивный поиск "ближайших точек" для каждого пикселя карты высот имеет сложность $O(N \\cdot M)$. Для оптимизации необходимо использовать пространственный индекс.

* **kdbush:** Сверхбыстрая библиотека для статической индексации 2D-точек (K-d tree). Она позволяет мгновенно находить соседей для интерполяции.18  
* **Алгоритм для Protocol TX:**  
  1. Загрузить точки класса "Земля" в kdbush.  
  2. Для каждого пикселя текстуры ландшафта запросить 5-10 ближайших соседей через kdbush.  
  3. Вычислить высоту методом IDW.  
  4. Записать результат в текстуру или буфер высот.

### **3.2. Рендеринг ландшафта: CDLOD**

Для отображения полученной карты высот наилучшим решением является алгоритм **CDLOD** (Continuous Distance-Dependent Level of Detail).

* **Принцип работы:** Ландшафт разбивается на квадродерево (Quadtree). Узлы дерева, близкие к камере, имеют высокую детализацию, далекие — низкую. Главная особенность CDLOD — плавный морфинг вершин при смене уровня детализации, что исключает визуальные "скачки" (popping) геометрии.20  
* **Реализация:** Существует готовая реализация TerrainCDLODBabylonJs для движка Babylon.js, использующая кастомные шейдеры для морфинга.20 Это решение поддерживает гигантские масштабы (вплоть до планетарных) и динамическую подгрузку чанков.

## ---

**4\. Векторная генерация зданий: Low-Poly архитектура**

Для зданий использование вокселей может быть избыточным или стилистически неподходящим. Альтернативный путь — процедурная генерация Low-Poly мешей из контуров зданий (OSM Footprints).

### **4.1. Парсинг и упрощение векторов**

Данные OSM (формат PBF) декодируются с помощью библиотек типа tiny-osmpbf или osm-pbf-parser-node.21  
Полученные полигоны часто содержат избыточные вершины (шум). Для достижения эстетики Low-Poly необходимо применить алгоритм упрощения Дугласа-Пекера (Ramer-Douglas-Peucker).

* **turf.simplify:** Модуль библиотеки Turf.js, который эффективно удаляет лишние точки на прямых линиях, сохраняя общую форму здания. Это критически важно для минимизации количества полигонов.23

### **4.2. Генерация крыш: Straight Skeleton**

Простое выдавливание (Extrusion) создает "коробки". Для создания скатных крыш необходим алгоритм Прямого Скелета (Straight Skeleton).  
В отличие от Медиальной Оси (которая дает параболические кривые на углах), Прямой Скелет состоит только из прямых линий, что идеально подходит для архитектурной геометрии.25

* **Библиотека straight-skeleton:** Это редкий пример сложного вычислительного геометрического алгоритма, доступного в JavaScript экосистеме. Современная версия использует WebAssembly (компиляция C++ библиотеки CGAL), что обеспечивает надежную работу даже со сложными полигонами, имеющими отверстия (внутренние дворы).26  
* **Применение:** На вход подается контур здания из OSM. На выходе получается граф ребер ("хребтов" крыши). Поднимая узлы скелета на высоту, пропорциональную расстоянию до края, мы получаем геометрически корректную скатную крышу.

## ---

**5\. Вычисления на GPU и WebGPU**

Учитывая масштаб данных Protocol TX, ресурсов CPU (даже с воркерами) может не хватить. Переход на WebGPU открывает возможности использования **Compute Shaders** — программ, выполняющих произвольные вычисления на видеокарте.

### **5.1. Генерация геометрии на GPU**

Вместо того чтобы рассчитывать позиции вершин вокселей или ландшафта на JavaScript, можно загрузить сырые данные (карту высот или 3D-массив типов вокселей) в StorageBuffer на GPU.

* **Compute Shader:** Шейдер запускается для каждого вокселя параллельно. Он проверяет условия (активен ли воксель, видим ли он) и записывает координаты вершин в выходной буфер, который затем напрямую используется для рендеринга.28  
* **Babylon.js и WebGPU:** Движок Babylon.js имеет передовую поддержку WebGPU. Примеры показывают возможность обновления вершинных буферов напрямую из Compute Shaders без копирования данных обратно на CPU, что устраняет главное узкое место производительности.29

## ---

**6\. Рекомендованная архитектура стека (Recommendation)**

На основе проведенного анализа для проекта Protocol TX рекомендуется следующая гибридная архитектура. Она сочетает лучшие специализированные инструменты для каждого типа данных.

### **Сводная таблица компонентов**

| Задача | Технология / Библиотека | Обоснование выбора |
| :---- | :---- | :---- |
| **3D Движок** | **Babylon.js** | Нативная поддержка CDLOD, продвинутая интеграция WebGPU, отличная работа с большими сценами. |
| **Загрузка данных** | **loaders.gl** (@loaders.gl/las) | Стандарт индустрии, работа в воркерах, доступ к классификации точек. |
| **Вокселизация** | **voxel-to-mesh** \+ **maxrects-packer** | Оптимизированное жадное построение сетки с поддержкой атласов текстур. |
| **Ландшафт** | **CDLOD** \+ **kdbush** (для IDW) | CDLOD решает проблему масштаба, kdbush ускоряет генерацию карт высот. |
| **Здания** | **osm-pbf-parser** \+ **straight-skeleton** | Единственный надежный способ процедурной генерации скатных крыш в вебе. |
| **Индексация** | **flatbush** | Статический R-tree индекс для сверхбыстрого пространственного запроса (culling) объектов. |
| **Семплинг** | **fast-2d-poisson-disk-sampling** | Для расстановки растительности (деревьев) с естественным распределением (Blue Noise). |

### **Сценарий интеграции (Workflow)**

1. **Серверный/Препроцессинг этап:**  
   * Сырые данные LAS парсятся через loaders.gl.  
   * Точки фильтруются: "Земля" идет на генерацию карты высот, "Объекты" — в воксельный буфер.  
   * Генерируется карта высот с помощью IDW (ускоренного через kdbush).  
   * Векторы OSM упрощаются (turf.simplify) и превращаются в 3D-модели зданий (straight-skeleton).  
   * Все статические меши (воксельные чанки и здания) объединяются и индексируются через flatbush для быстрого доступа.  
2. **Клиентский (Run-time) этап:**  
   * Движок (Babylon.js) запрашивает через flatbush список чанков, видимых камерой.  
   * Ландшафт рендерится через систему CDLOD, подгружая новые уровни детализации по мере приближения.  
   * Воксельные объекты и здания инстансируются (Thin Instances) для минимизации вызовов отрисовки.  
   * Для динамических эффектов (вода, частицы) задействуются WebGPU Compute Shaders.

Данная архитектура минимизирует риски, используя проверенные open-source решения, и обеспечивает масштабируемость, необходимую для работы с "тяжелыми" GIS-данными в браузере.

#### **Источники**

1. LASLoader | loaders.gl, дата последнего обращения: декабря 18, 2025, [https://loaders.gl/modules/las/docs/api-reference/las-loader](https://loaders.gl/modules/las/docs/api-reference/las-loader)  
2. Using Loaders \- loaders.gl, дата последнего обращения: декабря 18, 2025, [https://loaders.gl/docs/developer-guide/using-loaders](https://loaders.gl/docs/developer-guide/using-loaders)  
3. LASLoader | loaders.gl, дата последнего обращения: декабря 18, 2025, [https://loaders.gl/docs/modules/las/api-reference/las-loader](https://loaders.gl/docs/modules/las/api-reference/las-loader)  
4. Pointcloud (.laz) loading with classification support in three.js \- Questions, дата последнего обращения: декабря 18, 2025, [https://discourse.threejs.org/t/pointcloud-laz-loading-with-classification-support-in-three-js/63216](https://discourse.threejs.org/t/pointcloud-laz-loading-with-classification-support-in-three-js/63216)  
5. ericyd/node-las: LAS toolkit for working with Lidar data in Node \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/ericyd/node-las](https://github.com/ericyd/node-las)  
6. nationaldronesau/las-reader: Javascript library to manipulate and read Laz/Las files \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/nationaldronesau/las-reader](https://github.com/nationaldronesau/las-reader)  
7. jzwood/voxel-to-mesh: Converts voxel array to webgl mesh ... \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/jzwood/voxel-to-mesh](https://github.com/jzwood/voxel-to-mesh)  
8. Will Greedy Meshing Optimize Your Voxel Terrain? (GDScript vs. C\#) | Devlog & Tutorial, дата последнего обращения: декабря 18, 2025, [https://www.youtube.com/watch?v=0UwzP6GE08w](https://www.youtube.com/watch?v=0UwzP6GE08w)  
9. Greedy Meshing Algorithm Implementation : r/VoxelGameDev \- Reddit, дата последнего обращения: декабря 18, 2025, [https://www.reddit.com/r/VoxelGameDev/comments/cwtqtu/greedy\_meshing\_algorithm\_implementation/](https://www.reddit.com/r/VoxelGameDev/comments/cwtqtu/greedy_meshing_algorithm_implementation/)  
10. Greedy meshing in javascript \- James Hylands, дата последнего обращения: декабря 18, 2025, [https://www.jameshylands.co.uk/2022/10/greedy-meshing-in-javascript.html](https://www.jameshylands.co.uk/2022/10/greedy-meshing-in-javascript.html)  
11. mikolalysenko/greedy-mesher: Greedy mesh compiler \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/mikolalysenko/greedy-mesher](https://github.com/mikolalysenko/greedy-mesher)  
12. AThilenius/greedy\_meshing: Greedy Meshing Algorithm for Voxel Volumes \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/AThilenius/greedy\_meshing](https://github.com/AThilenius/greedy_meshing)  
13. soimy/maxrects-packer: A max rectangle 2d bin packer npm-module for packing glyphs or images into multiple sprite-sheet/atlas \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/soimy/maxrects-packer](https://github.com/soimy/maxrects-packer)  
14. Get colors from a voxelized mesh · Issue \#536 · mikedh/trimesh \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/mikedh/trimesh/issues/536](https://github.com/mikedh/trimesh/issues/536)  
15. Multiple Voxels with different texture. Performance \- Stack Overflow, дата последнего обращения: декабря 18, 2025, [https://stackoverflow.com/questions/11850359/multiple-voxels-with-different-texture-performance](https://stackoverflow.com/questions/11850359/multiple-voxels-with-different-texture-performance)  
16. How inverse distance weighted interpolation works \- ArcGIS Pro Resources, дата последнего обращения: декабря 18, 2025, [https://pro.arcgis.com/en/pro-app/latest/help/analysis/geostatistical-analyst/how-inverse-distance-weighted-interpolation-works.htm](https://pro.arcgis.com/en/pro-app/latest/help/analysis/geostatistical-analyst/how-inverse-distance-weighted-interpolation-works.htm)  
17. Inverse Distance Weighting (IDW) • SOGA-R \- Freie Universität Berlin, дата последнего обращения: декабря 18, 2025, [https://www.geo.fu-berlin.de/en/v/soga-r/Advances-statistics/Geostatistics/Inverse-Distance-Weighting-IDW/index.html](https://www.geo.fu-berlin.de/en/v/soga-r/Advances-statistics/Geostatistics/Inverse-Distance-Weighting-IDW/index.html)  
18. node-kdtree \- GitHub Pages, дата последнего обращения: декабря 18, 2025, [http://justinethier.github.io/node-kdtree/](http://justinethier.github.io/node-kdtree/)  
19. mourner/kdbush: A fast static index for 2D points \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/mourner/kdbush](https://github.com/mourner/kdbush)  
20. bpodwinski/TerrainCDLODBabylonJs: CDLOD Terrain and Geomorphing with Babylon.js \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/bpodwinski/TerrainCDLODBabylonJs](https://github.com/bpodwinski/TerrainCDLODBabylonJs)  
21. tiny-osmpbf \- NPM, дата последнего обращения: декабря 18, 2025, [https://www.npmjs.com/package/tiny-osmpbf](https://www.npmjs.com/package/tiny-osmpbf)  
22. borisgontar/osm-pbf-parser-node \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/borisgontar/osm-pbf-parser-node](https://github.com/borisgontar/osm-pbf-parser-node)  
23. simplify | Turf.js, дата последнего обращения: декабря 18, 2025, [https://turfjs.org/docs/7.2.0/api/simplify](https://turfjs.org/docs/7.2.0/api/simplify)  
24. simplify | Turf.js, дата последнего обращения: декабря 18, 2025, [https://turfjs.org/docs/api/simplify](https://turfjs.org/docs/api/simplify)  
25. Straight skeleton \- Wikipedia, дата последнего обращения: декабря 18, 2025, [https://en.wikipedia.org/wiki/Straight\_skeleton](https://en.wikipedia.org/wiki/Straight_skeleton)  
26. Straight skeleton algorithm implementation in TypeScript \- GitHub, дата последнего обращения: декабря 18, 2025, [https://github.com/StrandedKitty/straight-skeleton](https://github.com/StrandedKitty/straight-skeleton)  
27. straight-skeleton \- NPM, дата последнего обращения: декабря 18, 2025, [https://www.npmjs.com/package/straight-skeleton](https://www.npmjs.com/package/straight-skeleton)  
28. Compute Shaders | Babylon.js Documentation, дата последнего обращения: декабря 18, 2025, [https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/computeShader](https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/computeShader)  
29. The Compute Shader Tutorial \#1 \- Barth Cave, дата последнего обращения: декабря 18, 2025, [https://barthpaleologue.github.io/Blog/posts/the-compute-shader-tutorial-1/](https://barthpaleologue.github.io/Blog/posts/the-compute-shader-tutorial-1/)  
30. Data transfer from compute shader to renderer \- Questions \- Babylon.js Forum, дата последнего обращения: декабря 18, 2025, [https://forum.babylonjs.com/t/data-transfer-from-compute-shader-to-renderer/45576](https://forum.babylonjs.com/t/data-transfer-from-compute-shader-to-renderer/45576)